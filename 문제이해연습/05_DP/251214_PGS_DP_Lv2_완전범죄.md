# [251214_PGS_DP_Lv2_완전범죄]
> [문제 출처](https://school.programmers.co.kr/learn/courses/30/lessons/389480) <br/>

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - Info(N) <= 40, N(n) <= 120, M(m) <= 120
   - 목표 복잡도: O(N * M) -> 40 * 120 = 4,800 (충분)
- **유형 & 자료구조**: DP, Impl
- **핵심 로직 (Key Idea)**: 
   **[기존 접근: Greedy (X)]**
   > A 도둑 흔적 최소화, B 도둑 흔적 최대화 (단순 우선순위)
   1. [전처리]
      - 없음
   2. [메인 로직]
      - B가 훔칠 수 있으면 무조건 훔침 (m 미만)
      - 안되면 A가 훔침 (n 미만)
      - 둘 다 안되면 -1
   3. [최종 결과]
      - 불완전한 탐색으로 정답 보장 불가

   **[개선 접근: DP (O)]**
   > [모든 경우를 탐색하여 최적해 도출] "우리는 하나의 길을 걷는 게 아니라, 살아남은 모든 가능성을 펼쳐보다가, 겹치는 길이 나오면 더 안 좋은 길을 버리는 방식으로 전진합니다."
   1. [전처리] 
      - `dp[b]` 의미: B의 누적 흔적이 `b`일 때, A의 최소 누적 흔적.
   2. [메인 로직] (상태 전이)
      - `info`의 물건(traceA, traceB)을 하나씩 순회하며 `new_dp` 갱신.
      - **Case 1 (A가 훔침)**: `new_dp[b] = min(new_dp[b], dp[b] + traceA)` (단, `dp[b] + traceA < n`)
      - **Case 2 (B가 훔침)**: `new_dp[b + traceB] = min(new_dp[b + traceB], dp[b])` (단, `b + traceB < m`)
      - 각 물건 처리 후 `dp` 업데이트.
   3. [최종 결과] (return 값)
      - `min(dp)` 반환 (값이 INF면 -1 반환).
- **체크 포인트**:
   - [x] N=1 또는 0일 때 (최소 입력) -> 1 ≤ info의 길이 ≤ 40
   - [x] 정답이 음수이거나 0일 가능성 -> 불가능한 경우 -1 반환

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> 개념의 핵심 원리 한 줄 요약
- **DP (배낭 문제 변형)**:
  - 두 가지 비용(A흔적, B흔적)이 상충할 때, **하나를 인덱스(제한 조건)로, 다른 하나를 값(최소화 대상)**으로 설정하여 상태를 관리함.
  - 그리디(당장의 최선)가 전체의 최선을 보장하지 못할 때 사용.
- **Dynamic Programming (동적 계획법)**:
  - 복잡한 문제를 작은 부분 문제로 나누어 해결하고, 그 결과를 저장(Memoization)하여 중복 계산을 피하는 알고리즘 최적화 기법.
  - "큰 문제를 풀기 위해 작은 문제의 답을 기억해두었다가 재사용하는 것"이 핵심.

**② Python Code Snippet (패턴 저장)**
> 같은 B흔적이라면 A의 흔적은 다르게 될 수 있음. 같은 B흔적에서 A의 최솟값(min)만 기억하면 됨. 
>
> dp[b]의 의미: B의 누적 흔적이 b일 때, A의 최소 누적 흔적.
```python
def solution(info, n, m):
    INF = float('inf')
    # dp[b]: B의 누적 흔적이 b일 때, A의 최소 누적 흔적
    # b는 0부터 m-1까지 가능 (m 이상이면 잡힘)
    dp = [INF] * m
    dp[0] = 0
    
    for traceA, traceB in info:
        new_dp = [INF] * m # 매 물건마다 새로운 상태 기록
        for b in range(m):
            if dp[b] == INF: continue # 도달 불가능한 상태 패스
            
            # 1. A가 훔치는 경우 (A 흔적 증가, B 흔적 유지)
            # 조건: A의 누적 흔적이 n 미만이어야 함
            if dp[b] + traceA < n:
                new_dp[b] = min(new_dp[b], dp[b] + traceA)
            
            # 2. B가 훔치는 경우 (A 흔적 유지, B 흔적 증가)
            # 조건: B의 누적 흔적이 m 미만이어야 함
            if b + traceB < m:
                new_dp[b + traceB] = min(new_dp[b + traceB], dp[b])
                
        dp = new_dp # 상태 업데이트

    answer = min(dp)
    return answer if answer != INF else -1
```

---

## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] int 범위를 넘는 경우 (Python은 걱정 덜 해도 됨)
-------------------------------------------------------