# [260123_BOJ_Sim_B3_중앙_이동_알고리즘]
> [문제 출처](https://www.acmicpc.net/problem/2903) <br/>

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - N = 15 -> 모든 점의 개수 10^15 -> 메모리 초과 가능성
   - 시간제한 1초
- **유형 & 자료구조**: Sim(시뮬레이션) --> 수학 규칙을 찾아내야 함. (set 불가능)
- **핵심 로직 (Key Idea)**: 
   
   [수정전]
   1. [전처리]
   - 초기 상태의 점의 좌표를 정의 ; (0,0) (0, 1) (1, 0) (1,1)
   - 네 점의 가운데 좌표를 계산하는 식 정의
   - 점을 저장할 set(집합) 객채 초기화 (초기 점 추가)
   - 반복 횟수 n 입력 받음

   2. [메인 로직] (예외/탈출 조건 포함)
   - 네 점의 가운데 점의 좌표를 계산 (중간)
      - 만약 가운데 점이 이미 set에 존재하면 pass 
      - 존재 하지 않으면 다른 점의 좌표에 해당하는 4점의 좌표도 구함
         - set에 추가 
   - for 문을 통해 해당 작업 n번 반복 

   3. [최종 결과] (return 값)
   - n번 반복후 len(set) 반환 

   [수정후]
   1. [규칙 찾기] (Math)
   - 초기(N=0): 한 변의 점 2개 ➝ Total 4개 (2^2)
   - 1단계(N=1): 한 변의 점 3개 (2 + 1) ➝ Total 9개 (3^2)
   - 2단계(N=2): 한 변의 점 5개 (3 + 2, 즉 2^2 + 1) ➝ Total 25개 (5^2)
   - ...
   - **N단계 공식**: 한 변의 점 개수 = $2^N + 1$
   - **최종 정답**: $(2^N + 1)^2$

   2. [메인 로직]
   - N 입력
   - `side = 2**N + 1`
   - `print(side ** 2)`
   
- **체크 포인트**:
   - [x] N=1 또는 0일 때 (최소 입력)
   - [x] 데이터가 없는 경우 (Empty)
   - [x] 모든 값이 동일한 경우
   - [x] 정답이 음수이거나 0일 가능성
   - [x] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check)
   - [x] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [x] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> **시뮬레이션의 스케일(N)이 감당 안 될 땐, 반드시 '수학적 규칙(수열)'이 숨어있다.**
- **직접 구현 vs 규칙 찾기 판단 기준**:
  - $N$이 작으면(예: $N \le 20$ 정도라도 결과값이 작다면) 시뮬레이션 가능.
  - 하지만 이 문제처럼 $N=15$일 때 점의 개수가 $10^9$(10억)에 육박하면, 절대 메모리에 담을 수 없음 (메모리 초과).
- **규칙 발견(Pattern Finding)**:
  - $2 \xrightarrow{+1} 3 \xrightarrow{+2} 5 \xrightarrow{+4} 9 \dots$
  - 증가량이 $2^k$씩 늘어나는 구조 $\rightarrow$ 공비수열의 합 $\rightarrow$ $Side = 2^N + 1$

**② Python Code Snippet (패턴 저장)**
> 시뮬레이션이 불가능한 경우의 수식 계산
```python
# O(1) Math Solution
N = int(input())
# 시뮬레이션(set) 대신 공식 사용
side_dots = 2**N + 1  # 한 변의 점 개수
print(side_dots ** 2) # 전체 점 개수 = (한 변의 점)^2
```

---

<!-- 💡 사용 팁

## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check)
   - [ ] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [ ] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)
-------------------------------------------------------

-->