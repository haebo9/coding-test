1₩# [260204_BOJ_Greedy_G5_회의실_배정]
> [문제 출처](https://www.acmicpc.net/problem/1931) <br/>

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - N = 10^5 -> O(N)
   - s, e 는 0 또는 자연수 
- **유형 & 자료구조**: Greedy
- **핵심 로직 (Key Idea)**: 
> 전략 : 현재 회의를 최대한 빨리 끝내서, 다른 회의가 들어갈 여지를 많이 남긴다. 
   1. [전처리] 
      - 회의의 수를 입력 받는다. : n
      - 회의의 수만큼의 시작시간, 종료시간을 입력 받는다. : (s, e)
      - (key 1) 종료 시간이 빠른 순서(오름차순)로 정렬 / (key 2) 시작시간이 빠른 순서로 정렬 
   2. [메인 로직] (예외/탈출 조건 포함)
      - 마지막 종료시간을 갱신할 변수 초기화 : last_end = 0
      - 사용할 수 있는 최대 회의의 개수 초기화 : count = 0

      - 현재 회의 시간의 시작이 마지막 종료 시간보다 크거나 같으면: 
         - count += 1 # 회의가 진행됬다는 뜻. 
         - last_end = 현재 회의 시간의 종료
   3. [최종 결과] (return 값)
      - 사용할 수 있는 최대 회의의 개수 : count 출력 

- **체크 포인트**:
   - [x] N=1 또는 0일 때 (최소 입력)
   - [x] 데이터가 없는 경우 (Empty)
   - [x] 모든 값이 동일한 경우
   - [x] 정답이 음수이거나 0일 가능성
   - [x] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check)
   - [ ] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [ ] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> 활동 선택 문제 (Activity Selection Problem) - 그리디 최적해
- 한정된 자원(시간) 내에 겹치지 않는 활동을 최대로 선택하는 문제 유형.
- **"종료 시간이 빠른 순서대로 정렬"**하는 것이 핵심. (빨리 끝나야 남은 시간에 더 많은 활동을 할 수 있음)
- 시작 시간이 같다면, 더 빨리 끝나는 것을 먼저 선택해야 함. 따라서 **(종료 시간, 시작 시간) 이중 정렬**이 필수.

**② Python Code Snippet (패턴 저장)**
> 다중 조건 정렬 (Tuple Sort)
```python
# 1. 종료 시간(x[1]) 오름차순
# 2. 시작 시간(x[0]) 오름차순 (종료시간 같을 때)
meetings.sort(key=lambda x: (x[1], x[0]))
```


<!-- 💡 사용 팁

## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check)
   - [ ] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [ ] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)
-------------------------------------------------------

-->