# [251230_PGS_Queue_Lv2_기능개발]
> [문제 출처](https://school.programmers.co.kr/learn/courses/30/lessons/42586) <br/>
> **파일 네이밍 규칙**: `YYMMDD_플랫폼_유형_난이도_제목.md`
> - **플랫폼**: BOJ(백준), PGS(프로그래머스), SEA(삼성SW), LTC(리트코드)
> - **유형**: Impl(구현), BFS, DFS, Greedy, DP, Stack, Queue, Hash 등
> - **난이도**: Lv1, G5(골드5), S3(실버3) 등
> - **예시**: `251205_PGS_Impl_Lv1_유연근무제.md`

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - 작업 개수 <= 100 -> O(N)
   - 작업 진도, 속도 <= 100 
   - progresses 앞(죄측)에 있는 작업이 먼저 끝내야 뒤쪽도 끝날 수 있음 -> 선입선출(Queue)
- **유형 & 자료구조**: Queue
- **핵심 로직 (Key Idea)**: 
   1. [전처리] 
      - progresses를 Queue에 넣음
      - 빈 answer 리스트 정의
   2. [메인 로직] (예외/탈출 조건 포함)
      - 남아있는 작업이 있는지 확인 ; while 반복 실행
         - 맨 앞의 작업이 몇번 반복되어야 하는 지 계산 (진행률 100이 되도록)
            - `계산 방법 : (100 - progress) / speed` # added
            - 모든 작업에 대해 동일한 반복 횟수 만큼을 곱해준 뒤 진행률에 더함
            - 앞에부터 진행률이 100을 넘겼으면 deque (뽑아옴)
            - 뽑은 작업의 개수 만큼을 answer 리스트에 추가함
         - 다시 맨 앞의 작업에 대해 동일한 작업을 수행
      - 남아있는 작업이 없으면 
         - 반복문 탈출
   3. [최종 결과] (return 값)
      - 작업 끝난 개수가 담긴 answer 리스트 반환
- **체크 포인트**:
   - [x] N=1 또는 0일 때 (최소 입력) ; 명시되지 않음 -> 한번의 실행으로 종료
   - [x] 데이터가 없는 경우 (Empty) ; 명시되지 않음 -> 탈출 조건 추가
   - [x] 모든 값이 동일한 경우 -> 한번의 실행으로 종료 
   - [x] 정답이 음수이거나 0일 가능성 -> 작업 레스트가 비었을 경우 빈 리스트가 반환될 수는 있음 (음수 불가능)
   - [x] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check) -> 배열 내의 값의 합이 전체 작업 개수를 넘을 수 없음
   - [x] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [x] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념**
> 개념의 핵심 원리 한 줄 요약
- **남은 일수 계산 (`math.ceil`) + 순차적 배포**: 시뮬레이션 대신 `(100 - progress) / speed`의 올림값으로 남은 일수를 미리 계산한 뒤, 리스트를 한 번 순회하며 앞선 작업보다 빨리 끝나는 작업들을 그룹핑하는 방식이 더 효율적이다.

**② Python Code Snippet (패턴 저장)**
> 나중에 써먹을 수 있는 핵심 코드 조각
```python
import math

# 1. 남은 일수 계산 (올림 처리)
days = [math.ceil((100 - p) / s) for p, s in zip(progresses, speeds)]

# 2. 배포 로직 (앞선 작업이 끝날 때까지 대기)
answer = []
max_day = days[0]
count = 0

for day in days:
    if day <= max_day: # 앞 작업보다 빨리 끝나면 같이 배포
        count += 1
    else:             # 앞 작업보다 늦게 끝나면 정산 후 새로 시작
        answer.append(count)
        count = 1
        max_day = day
answer.append(count)
```

---

``
## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check)
   - [ ] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [ ] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)
-------------------------------------------------------
``