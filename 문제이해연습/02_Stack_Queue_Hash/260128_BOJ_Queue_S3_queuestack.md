# [260128_BOJ_Queue_S3_queuestack]
> [문제 출처](https://www.acmicpc.net/problem/24511) <br/>

## 1. 🔍 분석 (10분)
- **제약 & 복잡도**:
   - N = 10^5 -> O(N) # 삽입 횟수
   - M = 10^6 -> O(2M) # 기본 요소 개수 ; 넣고 빼고
   - C = 10^6 -> O(C) # 입력값 개수
   - 최종  -> O(N+2M)
   - 시간 제한 1초
- **유형 & 자료구조**: Queue, Stack 
- **핵심 로직 (Key Idea)**: 

   [`문제 이해`]
   - C의 수열이 모두 x0으로서 앞에서부터 queuestack에 삽입됨; 1번 자료구조 -> N번 자료구조
   1. [전처리]
      - N 길이의 수열 A 리스트 생성 (각 요쇼는 0-스택, 1-큐 자료형을 가짐)

   2. [메인 로직] (예외/탈출 조건 포함)
      - 삽입-추출 함수 생성
         - i 위치에서 큐 자료형이면 :
            - 기존의 값은 x(i-1)로 대체되고 
            - pop 된 기존의 값은 i+1 위치에 삽입
         - i 위치에서 스택 자료형이면 :
            - 기존의 값은 그대로 이고 x(i-1)은 다음으로 넘김
            - x(i) = x(i-1) -> i+1 위치에 삽입 
      - for 문으로 C의 값을 하나씩 뽑아서 x(0)으로 넣음 
         - x(n)의 최종 값을 result 리스트에 추가

   3. [최종 결과] (return 값)
      - result 리스트의 요소를 공백으로 구분하여 출력 

   `=> 피드백 : 시뮬레이션 방식으로 구현하면 시간초과 발생 -> 10^10번 연산`

   [`수정된 로직`]
   1. [전처리]
      - 자료구조 타입이 'Queue'(0)인 인덱스의 초기 값(B)만 추출하여 리스트(q_stack)로 만든다.
      - 이 값들은 나중에 들어온 값보다 먼저 나가야 하므로 순서를 뒤집거나 deque의 앞쪽에 배치한다.
      (전체 흐름: [초기 Queue 값들의 역순] ...... [새로운 입력 C])
   2. [메인 로직]
      - 사실상 Stack은 무시하고, Queue들의 값만 이어 붙인 하나의 긴 큐(Deque)처럼 동작한다.
      - deque를 생성하여 초기 Queue 값들을 넣는다.
      - 입력값 C를 하나씩 deque에 추가(appendleft)하고, 반대편에서 하나씩 뺀다(pop).
      - 혹은, Python 리스트 슬라이싱을 활용한다:
        - result = (queue_values[::-1] + C)[:M]
        - 전체를 합친 리스트에서 앞에서부터 M개만 자르면 정답이다.
   3. [최종 결과]
      - result 리스트 출력

- **체크 포인트**:
   - [x] N=1 또는 0일 때 (최소 입력)
   - [x] 데이터가 없는 경우 (Empty)
   - [x] 모든 값이 동일한 경우
   - [x] 정답이 음수이거나 0일 가능성
   - [x] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check)
   - [x] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [x] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)

---

## 2. 📚 학습 (5분)
> 이 문제를 통해 새로 알게 된 점이나 다시 확인한 개념을 정리합니다.

**① 오늘의 알고리즘/개념** 
> **복잡한 시뮬레이션 ➜ 자료구조의 본질 파악으로 최적화**
- **Stack (LIFO)**: 넣은 즉시 나오므로 파이프라인에서 아무런 영향이 없음 (Pass-through).
- **Queue (FIFO)**: 값을 저장했다가 새로운 입력에 밀려 나오는 역할 (Update Buffer).
- **Deque 추상화**: 여러 개의 Queue를 **하나의 긴 자료구조**처럼 생각하면, `[기존 Queue 값들] + [입력 값 C]`가 연결된 흐름이 됨.
- **복잡도 개선**: 시뮬레이션 $O(MN)$ ➜ 패턴 규칙 $O(M+N)$

**② Python Code Snippet (패턴 저장)**
> 리스트 슬라이싱을 이용한 Deque 패턴 (매우 간결!)
```python
# 1. type이 0(Queue)인 자료구조의 초기값만 수집 (순서 중요: 나중에 쌓인게 먼저 나감 -> 역순 배치 필요?? No, 큐는 선입선출)
# 실제 흐름: [Queue_1] -> [Queue_2] -> ...
# 데이터 흐름상: [Q_N 값] ... [Q_1 값] << [입력 C] 형태로 밀림
# 따라서 Q 값들을 역순으로 배치하고 C를 붙인 뒤 앞에서 M개를 자르면 됨.

queue_vals = [B[i] for i in range(N) if A[i] == 0]
# queue_vals[::-1] : 파이프라인의 출구 쪽에 가까운 순서로 정렬
final_result = (queue_vals[::-1] + C)[:M]

print(*final_result)
```

---

<!-- 💡 사용 팁

## 💡 참고 시트
> 유형, 자료구조, 복잡도, 체크 포인트를 정리합니다.

1. 🎯 목표 복잡도 가이드 (N의 크기 ➜ 시간 복잡도)
   - N ≤ 20     ➜ O(2^N)  : 백트래킹, 재귀, 완전탐색
   - N ≤ 1,000  ➜ O(N^2)  : 2중 For문, DP, 2차원 배열
   - N ≤ 10만   ➜ O(NlogN): 정렬, 힙, 이분탐색, 다익스트라, 유니온파인드
   - N ≤ 100만  ➜ O(N)    : 투 포인터, 그리디, DP, 스택/큐, 해시
-------------------------------------------------------
2. 🧩 알고리즘 유형 (파일명 약어)
   - [기본] Impl(구현), Sim(시뮬레이션), BF(브루트포스, 완전탐색)
   - [탐색] BFS(너비우선), DFS(깊이우선), Back(백트래킹), BinSearch(이분탐색)
   - [최적화] Greedy(그리디), DP(동적계획법)
   - [그래프] Dijkstra(다익스트라), Floyd(플로이드워셜), Topo(위상정렬), MST
   - [기타] TwoPtr(투 포인터), Sliding(슬라이딩 윈도우), Prime(소수판별)
-------------------------------------------------------
3. 📦 자료구조 선택
   - [선형] List(배열), Stack(스택), Queue(큐), Deque(덱)
   - [비선형] Graph(인접리스트/행렬), Tree(트리), Heap(우선순위 큐)
   - [검색/집합] Set(집합), Dictionary(해시맵)
-------------------------------------------------------
4. ⚠️ 필수 체크 포인트 (Edge Case)
   - [ ] N=1 또는 0일 때 (최소 입력)
   - [ ] 데이터가 없는 경우 (Empty)
   - [ ] 모든 값이 동일한 경우
   - [ ] 정답이 음수이거나 0일 가능성
   - [ ] 값의 변화가 특정 범위를 벗어나면 안 되는가? (Max/Min Check)
   - [ ] 재귀 깊이 제한 (sys.setrecursionlimit)
   - [ ] 리스트 복사 주의 (얕은 복사 vs 깊은 복사)
-------------------------------------------------------

-->